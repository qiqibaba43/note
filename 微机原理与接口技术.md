[TOC]



# 1.微型计算机基础

## 1.计算机中的数制

二进制 B              十进制  D       十六进制    H

十进制小数部分转二进制：***乘2取整***，直到小数部分为0

<font color="red">真值用符号表示正负数，机器数用符号位表示正负数</font>

## 2.计算机中的信息表示

- ASCII码

| 常用数字 | 对应的ASCII码 |
| :------: | :-----------: |
|   0~9    |    30H~39H    |
|   A~F    |    41H~46H    |
|  回车符  |      0DH      |
|  换行符  |      0AH      |

- BCD码

  - 紧凑型BCD码：一个字节八位存放一个两位十进制数
  - 非紧凑型BCD码：一个字节八位存放一个一位十进制数
- 有符号数的编码
  - 真值：一个数的数值
  - 机器数：0表示正，1表示负
  - 字长：包括符号位在内，一个二进制数占有的位数
- 原码，反码与补码
  - 原码：最高位为符号位，数值位位该数的绝对值
  - 反码：最高位位符号位，数值部分对正数是其绝对值，对负数时其***绝对值安按位取反***
  - 补码：对于正数的补码同原码，反码。负数的数值位为反码加一

***计算机中一律使用补码进行计算***

## 3.整数补码运算

一个计量器的最大容量称为计算器的模

$\textcolor{blue}{[x+y]补=[x]补+[y]补 [x-y]补=[x]补+[-y]补 }$

溢出与进位：

- 运算结构超过了运算器所能表示的范围
- 运算后，最高位向更高为进位

计算机表示进位与溢出：

![](https://gitee.com/qiqibaba43/image/raw/master/进位与溢出.png)

<font color="red">最高位的进位值保存在“进位标志寄存器”中。两个数的最高位相同，与结果的最高位相异，将溢出标志置为1</font>

程序员判断溢出：

- 无符号数：判断进位标志，进位标志等于一，表示溢出错
- 有符号数：判断溢出标志，溢出标志等于一，表示溢出错

## 4.计算机系统的基本组成

![](https://gitee.com/qiqibaba43/image/raw/master/计算机结构.png)

运算器和控制器称为中央处理器CPU

微处理器简称MPU

微型机的硬件结构

![](https://gitee.com/qiqibaba43/image/raw/master/微型计算机结构.png)

以CPU为核心通过3条***总线***连接存储器，I\O接口构成***微型计算机***。以其为主题，配上系统软件和外设，构成微型计算机

- CPU：即微处理器，内部集成了运算器，控制器，寄存器组等
- 存储器：指系统的主存储器，简称内存或主存，用来存放程序，数据
- I/O接口：CPU与外部设备交换信息的中转站
- 总线：CPU与存储器，I/O接口交换信息的公共通道
  - 地址总线：传输CPU访问存储器，访问I/O端口的地址信号
  - 数据总线：传输CPU读/写内存，读写I/O端口时的数据
  - 控制总线：传输CPU发出的控制命令，或外部向CPU提出的请求

****

读：输入，外部->CPU

写：输出，CPU->外部

****

## 5.存储器基本概念

- 存储元：存储器中的最小组成单位
- 存储单元：***CPU访问存储器基本单位***，由若干个具有相同操作属性的存储元组成
- 存储体：存储单元的集合
- 单元地址：在存储器中用于标识存储单元的唯一编号
- 存储器：存储体和地址译码器，读写控制电路等一起构成存储器

![](https://gitee.com/qiqibaba43/image/raw/master/存储器结构.png)

- 位（bit）：计算机中最小最基本的数据单位，作为单位时b
- 字节（byte）：由8个位二进制位组成，作为单位时B

存储单元的二进制地址码，由CPU通过***地址总线***送存储器的地址译码器的输入

***地址线条数决定了访问内存的容量***，n条地址线，可以访问$2^n$个字节存储容量

KB（$2^{10}$字节），MB（$2^{20}$字节）GB（$2^{30}$字节）

按存储器的读写功能：

- 只读存储器（ROM）：存放“基本输入/输出系统程序（BIOS）”

- 随机读写存储器（RAM）
  - 静态RAM：集成度低，信息稳定，读写速度快
  - 动态RAM：集成度高，容量大，信息存储不稳定，为此要不断进行“信息再生”，即刷新操作

|      名称      | 简称  |                用途                |           特点           |
| :------------: | :---: | :--------------------------------: | :----------------------: |
| 高速缓冲存储器 | cache |         告诉存储指令和数据         |      速度快，容量小      |
|    主存储器    | 主存  | 存放计算机运行期间的大量程序和数据 |    速度较快，容量不大    |
|   辅助存储器   | 外存  | 存放系统程序和大型数据文件及数据库 | 容量大，位成本低，速度慢 |



#  2.80*86微型处理器

## 1.常用术语

1. 位和字节

2. 字节（数据宽度）：微处理器一次可以直接处理的二进制的数码的位数，取决于微处理器内部通用寄存器的位数和数据总线的宽度
3. 寻址能力：CPU能直接存取数据的内存地址的范围，由CPU的地址总线的数目决定

## 2.通用寄存器

![](https://gitee.com/qiqibaba43/image/raw/master/通用寄存器.png)

其中AX，BX，CX，DX可以作为16位寄存器来用，也可以作为两个8位寄存器（高，低位）来用。低位字节的寄存器别称为AL，BL，CL，DL。高位寄存器别称AH，BH，CH，DH。这8个16位寄存器被分为3类：数据寄存器，变址寄存器和指针寄存器

- 数据寄存器：AX，BX，CX和DX。

  - AX称为累加器，使用频率最高，用于算数，逻辑运算以及外设传送信息
  - BX称为基址寄存器，常用于存放存储器地址
  - CX称为计数器，作为循环和串操作等指令的隐含计数器
  - DX称为数据寄存器，常用于存放双字长数据的高16位

- 变址寄存器：SI和DI

  常用于存储器变址寻址方式时提供地址

  - SI是源变址寄存器
  - DI是目的变址寄存器

- 指针寄存器：BP和SP

  用于寻址内存区堆栈段的数据

  - SP为堆栈指针寄存器，指示堆栈段栈顶的位置（偏移地址）
  - BP为基址指针寄存器。SP和BP寄存器与BB段寄存器联合使用确定堆栈段中的存储单元

## 3.段寄存器

![](https://gitee.com/qiqibaba43/image/raw/master/段寄存器.png)

- 段寄存器：CS，DS，ES和SS
  - CS称为代码段寄存器，用于存放代码段的段地址
  - DS称为数据段寄存器
  - ES称为附加段寄存器。DS和ES都用于存放数据段和附加数据段的段地址
  - SS称为堆栈寄存器，用于存放堆栈段的段地址，指示堆栈区域的位置

## 4.标志寄存器

![](https://gitee.com/qiqibaba43/image/raw/master/标志寄存器.png)

分别为标志位和控制位

- 标志位：指明程序运行时微处理器的实时状态
- 控制位：由程序设计者设置，以控制CPU进行某种操作

## 5.指令指针寄存器、

![指令指针寄存器](https://gitee.com/qiqibaba43/image/raw/master/202303092135223.png)、
- 指令寄存器：IP

  IP为指令寄存器，指示内存中指令的位置。随着指令的执行，IP将自动修改以指示下一条指令所在的存储器位置。指令指针寄存器是一个专用的寄存器，与CS段寄存器联合使用以确定下一条指令的存储单元地址

# 3.汇编语言指令集

## 1.概述

 指令是CPU操作的基本单位，每条指令执行一个特定的操作

指令的分类：

- 机器指令：二进制格式编码的序列
- 符号指令：用字符串形式的序列表示

指令的组成：

| 标号： | 操作码助记符 | 空格 | 操作数助记符 | ；注释 |
| :----: | :----------: | :--: | :----------: | :----: |

- 标号：标号又称符号地址，表示该指令的逻辑地址
- 操作码：计算机要执行的操作
- 操作数：执行操作过程索要操作的数
- 注解：以“；”开头，不执行

`ADD AX,BX;AX寄存器中的数与BX寄存器中的数相加后和送入AX寄存器中`

指令长度：指令在存储器中占用的字节数称为指令长度

指令地址：多字节指令占用连续的内存单元，存放指令第一个字节的内存单元地址，称为指令地址

指令的存放：首先存放操作码，然后存放操作数。多字节操作数连续存放，顺序依据***小端法***———低位字节存放在低地址单元，高位字节存放在相邻的高地址单元

## 2.标志寄存器

![](https://gitee.com/qiqibaba43/image/raw/master/标志寄存器详细.png)

32位CPU标志寄存器为32位，实际使用15位

15位标志分类：

- 状态标志：记录了当前指令执行后的状态信息

- 控制标志：用来控制未处理器操作

### 1.C标志--进位/借位标志

最高位产生进位/借位时，C标志置1，否则置0

### 2.A标志--辅助进位/辅助借位标志

也称半进位/借位标志。如果产生了进位，或者借位，A标志置1，否则置0。

$当运算为字或者双字的时候，A标志的设置只与D_{3}位向D_{4}位的进位/借位有关$

### 3.S标志--符号标志

最高位为1，S标志置1，否则置0

### 4.Z标志--全零标志

运算结果全为0，Z标志置1，否则置0

### 5.P标志--奇偶标志

运算结果***低8位***中，1的个数位偶数个，P标志置1，否则置0

### 6.O标志--溢出标志

加数与被加数的最高位相同，与结果的最高位相异，O标志置1，否则置0

## 3.寻址方式

操作数的存放位置：

- 立即数：操作数作为指令的一部分，直接包含在指令中
- 寄存器操作数：操作数存放在CPU的寄存器中
- 存储器操作数或内存操作数：操作数存放在计算机的存储器中
- I/O端口操作数：操作数存放在计算机接口电路的端口中

### 1.立即寻址

操作数包含在指令中，是指令的一个组成部分。CPU读取该指令后就获得了操作数

说明：

1. 立即寻址常用于给寄存器或内存操作数赋值，并且只能用于源操作数，不能用于目标操作数
2. 立即数在以二进制表示的时候，在数值后加上B，十六进制在后面加上H，并且***开头为A~F时，需要在前面加上前缀0***，八进制在后面加上Q
3. 立即数可以是算术表达式，在生成机器指令时，要以实际计算结果作为操作数

### 2寄存器寻址

操作数在CPU的某个寄存器中，符号指令直接写出寄存器名称

### 3.存储器操作数寻址

读写内存操作数之前，CPU必须知道相关存储单元的物理地址。由于CPU对存储器才去分段管理，指令格式中只能写出存放操作数的内存单元的逻辑地址

$\textcolor{green}{段寄存器:偏移地址}$

#### 1.直接寻址

1) $\textcolor{green}{段寄存器：[偏移地址]}$

 ```
 例：MOV AL,ES:[2CH];
 ```

2. $\textcolor{green}{段寄存器:[变量名]}$

```
例：MOV AL,XX;
```

常用于存取单个内存操作数

#### 2.寄存器间接寻址

操作数在存储单元，该单元的段基址在段寄存器中，偏移地址在间址寄存器中

$\textcolor{green}{段寄存器：[间址寄存器]}$

物理地址=段寄存器内容*16+间址寄存器

|                间址寄存器                |       约定访问的逻辑段        | 寻址位数 |
| :--------------------------------------: | :---------------------------: | :------: |
|                    BP                    |            堆栈段             |    16    |
|     <font color=red>BX,SI,DI</font>      | <font color=red>数据段</font> |    16    |
|                 EBP，ESP                 |            堆栈段             |    32    |
| <font color=red>EAX~EDX，ESI，EDI</font> | <font color=red>数据段</font> |    32    |

适合存取按一定规律连续存放在存储器中的多个数据

#### 3.基址寻址

$\textcolor{green}{段寄存器：[基址寄存器+位移量]}$

|                间址寄存器                |       约定访问的逻辑段        | 寻址位数 |
| :--------------------------------------: | :---------------------------: | :------: |
|                    BP                    |            堆栈段             |    16    |
|        <font color=red>BX</font>         | <font color=red>数据段</font> |    16    |
|                 EBP，ESP                 |            堆栈段             |    32    |
| <font color=red>EAX~EDX，ESI，EDI</font> | <font color=red>数据段</font> |    32    |

#### 4.变址寻址

$\textcolor{green}{段寄存器：[比例因子*变址寄存器+位移量]}$

其中比例因子只能是1，2，4，8

|                间址寄存器                |       约定访问的逻辑段        | 寻址位数 |
| :--------------------------------------: | :---------------------------: | :------: |
|       <font color=red>SI,DI</font>       | <font color=red>数据段</font> |    16    |
|                   EBP                    |            堆栈段             |    32    |
| <font color=red>EAX~EDX，ESI，EDI</font> |            数据段             |    32    |

#### 5.变址寻址和基址寻址

1. $\textcolor{green}{段寄存器名称：[基址寄存器+比例因子*变址寄存器+位移量]}$
2. $\textcolor{green}{段寄存器名称：[基址寄存器+变址寄存器+位移量}$

## 4.汇编语言

汇编语言源程序：指令性语句和指示型语句

- 指令性语句：符号指令

  包括***伪指令***和***宏指令***

1. 汇编语言语句类型为指令性语句时的书写规范：

$\textcolor{green}{标号：操作码助记符\quad 空格 \quad操作数助记符 ；注释}$

2. 汇编语言语句类型是指示性语句时的书写规范

$\textcolor{green}{变量 \quad伪指令助记符号 \quad空格 \quad操作数项 ；注释}$

命名规则：以除数字意外的字母或者符号开头，后面跟字符，数字···长度小于31个字符

### 1.常用的伪指令

#### 1.字节定义伪指令

$\textcolor{green}{变量名 \quad DB\quad 一个或多个用逗号间隔的单字节数}$

说明：DB--Define byte的缩写

​			？--随机数

​			3 Dup(?)表示3个用逗号隔开的随机数

​			5 Dup('A')表示5个用逗号隔开的A的ASCLL码

#### 2.字定义伪指令

$\textcolor{green}{变量名\quad DW \quad 一个或多个用逗号隔开的双字节数}$

说明：DW--Define Word

​			？--双字节随机数

​		     存放时按照小端法

#### 3.双字定义伪指令

$\textcolor{green}{变量名\quad DD\quad 一串用逗号隔开的4字节数}$

而且DD可以省略

#### 4.多字节定义伪指令

- DF   6字节数
- DQ  8字节数
- DT   10字节数

#### 5.等值伪指令

$\textcolor{green}{符号常数\quad EQU \quad表达式}$

如：NUM EQU 33

说明：定义符号常数NUM的值为33

#### 6.等号伪指令

$\textcolor{green}{符号常数 = 表达式}$

***等值伪指令与等号伪指令的区别：用EQU定义的常数符号在后续语句中不可以修改，而“=”定义的可以修改***

### 2.常用运算符

#### 1.算数运算符

+，-，*，/

#### 2.关系运算符

EQ（等于），NE（不等于），GT（大于），LT（小于），GE（大于等于）

#### 3.$运算符

汇编程序对源程序时逐行汇编的，可以返回汇编计数器的当前值

***包括空格***

#### 4.SEG运算符

$\textcolor{green}{SEG \quad 段名或变量名或标号名}$

计算某一逻辑段的段基址

#### 5.PTR运算符

$\textcolor{green}{类型说明符 \quad PTR\quad 表达式地址}$

***在本条指令中临时修改表达式的属性***

:star:使用规则：

1. 指令的操作数至少一个类型属性要确定，否则必须用PR运算符说明其中的内存操作数的类型
2. 两个操作数的类型属性都确定，则必须保持一致。否则必须用PTR运算符改变其中的内存操作数的类型，以保持前后属性一致

应用场景：

- 在$\textcolor{red}{双操作数}$指令中
  1. 源操作数为立即数，目标操作数为直接寻址的存储器操作数，后者必须用PTR临时修改其属性，使源目类型一致
  1. 源操作数为立即数，目标操作数为间址，变址，基址或基址加变址寻址的存储器操作数，***无论两者类型属性是否一致***，后者必须用PTR显示说明其类型
  1. 源操作数和目标操作数中一方是寄存器操作数，另一方为直接寻址的存储器操作数，但两者类型属性不一致，必须用PTR临时修改其中的存储器操作数的类型
- 在$\textcolor{red}{单操作数}$指令中
  1. 操作数为间址，变址，基址或基址加变址寻址的存储器操作数，必须用PTR说明是字节操作，字操作，还是双字操作
  2. 操作数是直接寻址方式的存储器操作数，根据操作数的类型属性是否与指令规定的操作数的类型属性一致

#### 6.方括号运算

访问内存操作数常用的寻址方式，下标从0开始。变量相当于一个数组

#### 7.OFFSET运算符

$\textcolor{green}{OFFSET \quad变量名或标号名}$

算出逻辑段某个变量或标号名所在单元相对于段首的偏移地址

## 5..汇编语言基本指令集

- N：表示立即数
- R：表示寄存器操作数
- M：表示内存操作数
- S：表示段寄存器

[查看寻址方式](##2.通用寄存器)

:star:双操作数指令：

1. 源，目操作数不可同为内存操作数
2. 源，目操作数属性一致（长度相同）
3. 当目标操作数为间址，变址，基址，基址加变址的内存操作数，而源操作数为单字节或双字节立即数，目标操作数必须用PTR说明类型

:star:单操作数指令：

操作数为间址，变址，基址，基址加变址的内存操作数，必须用PTR说明类型

### 1.通用传送

#### 1.数据传输

$\textcolor{green}{MOV \quad目标操作数，源操作数}$

|    目标操作数     | 源操作数 |
| :---------------: | :------: |
|        R/M        |    N     |
| R/M/S（不能是CS） |    R     |
|        R/M        |    S     |
|  R/S（不能是CS）  |    M     |

将源操作数赋值给目标操作数，不影响六种标志

#### 2.有效地址传送

又称偏移地址传送

$\textcolor{green}{LEA\quad REG，SRC}$

REG：十六位通用寄存器

SRC：内存操作数

#### 3.交换指令

$\textcolor{green}{XCHG\quad OPRD1，OPRD2}$

寄存器和存储器间交换信息，$\textcolor{red}{不能使用段寄存器}$

#### 4.查表指令

$\textcolor{green}{XLAT \quad 表头变量名}$

### 2.堆栈操作指令

先进后出原则

- 堆栈段寄存器SS：存放堆栈段段基址
- 堆栈指针SP：存放栈顶单元的偏移地址

#### 1.进栈指令

$\textcolor{green}{PUSH \quad 源操作数}$

$\textcolor{red}{非直接寻址的内存操作数，必须用PTR说明属性}$

#### 2.出栈指令

$\textcolor{green}{POP \quad 目标操作数}$

$\textcolor{red}{非直接寻址的内存操作数，必须用PTR说明属性}$

#### 3.16位标志寄存器入栈指令

$\textcolor{green}{PUSHF}$

将16位标志寄存器Flag的内容压入堆栈保存

#### 4.16位标志寄存器出栈指令

$\textcolor{green}{POPF}$

将栈中内容淡出至16位标志寄存器Flag

### 3.加法类指令

#### 1.ADD

$\textcolor{green}{ADD \quad DST,SRC}$

源操作数：通用寄存器，存储器，立即数

目标操作数：通用寄存器，存储器

***影响标志位，适用于有符号数和无符号数***

#### 2.ADC

$\textcolor{green}{ADC \quad DST,SRC}$

源操作数：通用寄存器，存储器，立即数

目标操作数：通用寄存器，存储器

主要用于多字节运算

$\textcolor{green}{DST=DST+SRC+C}$   C表示进位标志

***影响标志位，适用于有符号位和无符号位***

#### 3.INC

$\textcolor{green}{INC \quad OPRD}$

操作数：通用寄存器，存储器（不能是段寄存器，立即数）

用于循环中修改地址指针及循环次数

$\textcolor{red}{将操作数视为无符号操作数，不影响进位标志C}$

### 4.减法类

#### 1.SUB

$\textcolor{green}{SUB \quad DST,SRC}$

源操作数：通用寄存器，存储器，立即数

目标操作数：通用寄存器，存储器

***影响标志位，适用于有符号数和无符号数***

#### 2.SBB

$\textcolor{green}{SBB \quad DST,SRC}$

源操作数：通用寄存器，存储器，立即数

目标操作数：通用寄存器，存储器

$\textcolor{green}{DST=DST-SRC-C}$

***影响标志位，适用于有符号数和无符号数***

#### 3.DEC

$\textcolor{green}{DEC \quad OPRD}$

自减减操作

$\textcolor{red}{将操作数视为无符号操作数，不影响进位标志C}$

#### 4.NEG

$\textcolor{green}{NEG \quad OPRD}$

操作数：通用寄存器，存储器

求补指令

***影响标志位***

### 5.乘法类

#### 1.MUL

$\textcolor{green}{MUL \quad SRC}$

无符号数乘法

源操作数：通用寄存器，存储器（不能是立即数）

目标操作数：DX，AX（隐藏）

字节操作数：$\textcolor{green}{(AH,AL)\leftarrow (AL)*(SRC)}$

字操作：$\textcolor{green}{(DX,AX)\leftarrow(AX)*(SRC)}$

$\textcolor{red}{SRC的类型决定了是字或字节相除}$

#### 2.IMUL

$\textcolor{green}{MUL \quad SRC}$

带符号数乘法

源操作数：通用寄存器，存储器（不能是立即数）

目标操作数：DX，AX（隐含）

字节操作数：$\textcolor{green}{(AH,AL)\leftarrow (AL)*(SRC)}$

字操作：$\textcolor{green}{(DX,AX)\leftarrow(AX)*(SRC)}$

### 6.除法类

$\textcolor{green}{DIV \quad SRC}$    无符号数除法

$\textcolor{green}{IDIV \quad SRC}$   带符号数法

源操作数：通用寄存器，存储器（不能是立即数）

目标操作数：DX，AX（隐含）

字节操作 ：$\textcolor{green}{(AH)\leftarrow (AX) /(SRC)}$           ——商

​						$\textcolor{green}{(AH,AL)\leftarrow (AX)*(SRC)}$——余数

字操作数      $\textcolor{green}{(AX)\leftarrow(DX,AX)/(SRC)}$  ——商

​						$\textcolor{green}{(DX)\leftarrow (DX,AX)/(SRC)}$  ——余数

$\textcolor{green}{对标志位均无定义，SRC的类型决定是字或字节相除}$

### 7.BCD码调整指令

- BCD码——用二进制编码的十进制数
- ![BCD码](https://gitee.com/qiqibaba43/image/raw/master/202303071906930.png)
 四位二进制数代表一位十进制数，逢十进一，借一当十

| 加法 | DAA  |  组合  |
| :--: | :--: | :----: |
| 加法 | AAA  | 未组合 |
| 减法 | DAS  |  组合  |
| 减法 | AAS  | 未组合 |
| 乘法 | AAM  | 未组合 |
| 除法 | ADD  | 未组合 |

### 8.转移和调用指令

按条件分类：

- 无条件转移
- 有条件转移

按范围分类：

- 段内转移
- 段间转移

按获取转移地址的方法分类：

- 直接转移
- 间接转移

|         分类         |                指令                |                 功能                 |
| :------------------: | :--------------------------------: | :----------------------------------: |
|    无条件转移指令    | $\textcolor{red}{JMP \quad OPRD}$  |              无条件转移              |
|     条件转移指令     |  $\textcolor{red}{JNZ\quad OPRD}$  | 根据上一条指令设置的标志位的情况转移 |
|       循环指令       | $\textcolor{red}{LOOP \quad OPED}$ |             计数非零循环             |
|                      |      $LOOPE/LOOPZ\quad OPRD$       |      计数非零循环且结果为0循环       |
|                      |     $LOOPNE/LOOPNZ\quad OPRD$      |     计数非零循环且结果不为0循环      |
| 子程序调用及返回指令 | $\textcolor{red}{CALL\quad OPRD}$  |              调用子程序              |
|                      |               $RET$                |             从子程序返回             |
|       中断指令       |           $INT \quad N$            |               软件中断               |
|                      |               $INTO$               |              溢出时中断              |
|                      |               $IRET$               |               中断返回               |

#### 1.无条件转移指令

$\textcolor{green}{JMP\quad <转向地址>}$

#### 2.条件转移指令

特点：

- 条件转移指令全部为段内转移
- 目标地址在当前指令的-128~127范围内
- 目标地址由操作数决定
- 条件转移不影响标志位

无符号数大小的比较：

|      指令       |     功能      | 转移条件 |
| :-------------: | :-----------: | :------: |
| $JC\quad OPRD$  |  低于/有借位  |   C=1    |
| $JNC\quad OPRD$ | 不低于/无借位 |   C=0    |
| $JNA\quad OPRD$ |    不高于     | C OR Z=1 |
| $JA\quad OPRD$  |     高于      | C OR Z=0 |

带符号数大小比较：

|      指令       |  功能  |    转移条件    |
| :-------------: | :----: | :------------: |
| $JL\quad OPRD$  |  小于  | S XOR O=且Z=0  |
| $JGE\quad OPRD$ | 不小于 | S XOR O=1且Z=1 |
| $JLE\quad OPRD$ | 不大于 | S XOR O=1且Z=1 |
| $JG\quad OPRD$  |  大于  | S XOR O=1且Z=0 |



#### 3.循环控制转移指令

|            指令            |            功能            |    循环条件     |
| :------------------------: | :------------------------: | :-------------: |
|     $LOOP \quad OPRD$      |      计数器不为零循环      |   $CX\neq 0$    |
|  $LOOPZ/LOOPE \quad OPRD$  | 计数器不为零且相等时循环环 | $CX\neq 0且Z=1$ |
| $LOOPNZ/LOOPNE \quad OPRD$ | 计数器不为零且不相等时循环 | $CX\neq 0且Z=1$ |

![循环流程](https://gitee.com/qiqibaba43/image/raw/master/202303102203977.jpg)

#### 4.子程序调用及返回指令

$$
\textcolor{green}{CALL\quad <调用地址>}\\ \textcolor{green}{RET}
$$

:star:调用：调用子程序

:star:返回：返回断点

:star:子程序：能完成一定功能的相对独立的程序段

*****

汇编语言的子程序定义语句
$$
子程序名\quad PROC\quad 属性\\
	子程序实体\\
	子程序名\quad ENDP
$$
说明：

- 子程序名：以字母开头，长度小于等于31
- 经汇编后，子程序名就是子程序第一条指令的地址
- PROC/ENDP是子程序的定界语句
- 属性：
  - NEAR（可缺省）：代表近子程序，子程序与调用它的指令在同一个代码段
  - FAR：代表远子程序，子程序与调用它的指令不在同一个代码段
  - RET：子程序返回指令

****

### 9.逻辑运算指令

#### 1.逻辑运算指令

- 逻辑与

  $\textcolor{green}{AND\quad DST,SRC}$

  O=0，C=0，P，S，Z反应操作结果

  常用于将某些位变0，比如低四位，ADD AL，F0

- 逻辑或

  $\textcolor{green}{OR\quad DST,SRC}$

  O=0,C=0,P,S,Z反应操作结果

  用于将某些位变1，比如低四位，OR AL，0F

- 异或

  $\textcolor{green}{XOR\quad DST,SRC}$

  按位异或运算，同则为0，异则为1

  O=0，C=0，P，S，Z反应操作结果

- 测试

  $\textcolor{green}{TEST\quad DST,SRC}$

  实现两个操作数的按位与运算，结果不保存，只影响标志位

  O=0，C=0，P，S，Z反应操作结果

  ***常用于检测一些条件是否满足，又不希望改变操作数***

- 逻辑非

  $\textcolor{green}{NOT\quad OPRD}$

  按位取反

  不影响标志位

#### 2.一般移位指令

算数位移常用于带符号运算，逻辑移位常用于无符号运算

- 算数/逻辑左移

  $\textcolor{green}{SAL\quad OPRD,CNT}$		算数左移

  $\textcolor{green}{SHL\quad OPRD,CNT}$		逻辑左移

  CNT：$\textcolor{red}{移位次数，只能是立即数或CL寄存器}$

  ![算数逻辑左移](https://gitee.com/qiqibaba43/image/raw/master/202303102204119.jpg)

- 算数右移

  $\textcolor{green}{SAR\quad OPRD,CNT}$

  ![算数右移](https://gitee.com/qiqibaba43/image/raw/master/202303102205201.jpg)

- 逻辑右移

  $\textcolor{green}{SHR\quad OPRD,CNT}$
  
  ![逻辑右移](https://gitee.com/qiqibaba43/image/raw/master/202303102205332.jpg)

#### 3.循环移位指令

- 循环左移

  $\textcolor{green}{ROL\quad OPRD,CNT}$

  ![循环左移](https://gitee.com/qiqibaba43/image/raw/master/202303102206059.jpg)

- 循环右移

  $\textcolor{green}{ROR\quad OPRD,CNT}$![循环右移](https://gitee.com/qiqibaba43/image/raw/master/202303102206647.jpg)

- 带进位的循环左移

  $\textcolor{green}{RCL\quad OPRD,CNT}$

  ![](https://gitee.com/qiqibaba43/image/raw/master/202303102207900.jpg)

- 带进位的循环右移

  $\textcolor{green}{RCR\quad OPRD,CNT}$

  ![带位循环右移](https://gitee.com/qiqibaba43/image/raw/master/202303102207220.png)
  
  
### 10.串操作指令

  串是由若干位相同类型的元素构成的序列。在汇编语言中，常用的元素有：字节，字和双字

- 字节串：STR串有8字节型的元素
- 字串：STR串有4个字型的元素
- 双字串：STR串有2个双字型的元素

串操作指令的操作对象为源串和目标串。$\textcolor{red}{源串定义在数据段，目标串定义在ES附加段}$

采用16位寻址方式，SI间址访问数据段中的源串，DI间址访问ES福建段中的目标串，使用CX作为串计数器

#### 1.基本型

- 字节传送 $\textcolor{green}{MOVSB}$
- 字传送$\textcolor{green}{MOVSW}$
- 双字传送$\textcolor{green}{MOVSD}$

将源串中的一个元素传送到目标串的对应存储单元，然后依据方向标志D修改串指针SI和DI

D=0，表示传送方向为增址型传送，即从串的低地址端想高地址端依次传送。

举例：字传送时，$DS:[SI]$的一个字型元素赋给$ES:[DI]$，然后$(SI)+2\rightarrow(SI),(DI)+2\rightarrow(DI)$

D=1，则恰好相反。字节传送时，$(SI)-1\rightarrow(SI),(DI)-1\rightarrow(DI)$

#### 2.有重复前缀

- 重复字节传送$\textcolor{green}{REP\quad MOVSB}$
- 重复字传送$\textcolor{green}{REP\quad MOVSW}$
- 重复双字传送$\textcolor{green}{REP\quad MOVSD}$

将源串中的一个元素传送给目标串的对应存储单元，然后依据方向标志D修改串指针SI和DI，进行下一个元素的传送。$\textcolor{red}{知道（CX）=0为止结束传送}$

# 4.汇编语言程序设计

## 1.汇编语言程序结构

结构上的要求：

1. 用方式选择伪指令说明该程序的CPU类型
2. 用段定义伪指令定义每一个逻辑段
3. 用$ASSUME$语句说明段约定
4. 用汇编结束伪指令说明源程序结束

### 1.处理器选择伪指令

不同处理器的指令系统不完全相同。方式选择伪指令以“.”开头主要包括.8086，.286

### 2.段定义伪指令

段定义伪指令`SEGMENT`和`ENDS`用于定义一个逻辑段，是逻辑段的定界语句，表示一个逻辑段的开始和结束

格式：

```
段命 SEGMENT 定位参数 链接参数 ‘分类名’ 段长度
	 段体
段名 ENDS
```

- 段名：段名的命名规则与变量名一致，段名不能代表段体的性质。但一般根据段体的性质起一个适当的段名。DATA作为数据段的段名，SRTACK作为堆栈段，CODE作为代码段
- 定位参数：定义逻辑段在存储器中如何存放
- 链接参数：又称组合，通知链接程序如何将不同模块中的同名逻辑段组合成一个段
- ‘分类名’：表示逻辑段的类型
- 段长度：
  - USE16：表示逻辑段长度最大允许64k，单元有效地址为16位，采用16位寻址方式
  - USE32：表示逻辑段长度可以超过64k，单元有效地址为32位，采用32位寻址方式

### 3.段约定伪指令

格式：

$\textcolor{green}{ASSUME\quad 段寄存器：段名，……，段寄存器：段名}$

通知汇编程序，寻址逻辑段使用哪一个段寄存器

仅约定对某个逻辑段进行寻址操作时选用哪一个段寄存器，二段寄存器的初值还必须在程序中用指令设置

### 4.汇编结束语句

$\textcolor{green}{END\quad 程序的启动地址标号}$

### 5.返回DOS

在执行完程序后必须返回DOS

```
MOV AH,4CH
INT 21H
```

INT是intrupte的缩写

汇编源程序有两种编程格式：

- EXE

  允许源程序使用多个逻辑段，每个逻辑段的目标块不超过64k，适合编写大型程序

- COM

  只允许源程序使用一个逻辑段（代码段），适合编写中小程序，COM文件的执行级别高于EXE文件

## 2.功能调用

### 1.DOS功能调用

操作系统：不同操作系统提供不同的子程序和库函数供程序员调用

用户通过`INT 21H`软中断指令调用DOS系统功能，在为每个功能调用规定一个功能号作为子程序的入口

1. 用`MOV AH,功能号`设置系统功能调用号
2. 用指定的寄存器设置入口参数
3. 用指令`INT 21H`执行功能调用
4. 根据出口参数分析功能调用调用

:star:常用功能号：

- 01H

  等待键入一个字符，同时将该输入字符显示在屏幕上，响应Ctrl+C

  入口参数：无

  出口参数：AL=按键的ASCII。如果AL=0，表明按键是功能键，光标键，还需要再调用本功能，才能返回按键的扩展码

****

Ctrl+C：中断程序指令，杀死进程

扩展码：标准ASCII使用七位二进制数表示所有的大写和小写字母，0~9，标点符号和特殊控制符。而扩展码将每个字符的第八位用于确定附加的128个特殊字符

****

- 02H

  显示一个字符，响应Ctrl+C

  入口参数：DL=待显示的字符的ASCII

  出口参数：无

  $\textcolor{red}{会破坏AL寄存器的内容}$

  举例：在屏幕上显示字符A

  ```
  MOV DL,'A'
  MOV AH,02H
  INT 21H
  ```

- 07H

  等待键入一个字符，但不显示，且不响应Ctrl+C

  入口参数：无

  出口参数：AL=按键的ASCII。如果AL=0，表明按键是功能键，光标键，还需要再调用本功能，才能返回按键的扩展码

- 08H

  等待键入一个字符，但不显示，响应Ctrl+C

  入口参数：无

  出口参数：AL=按键的ASCII。如果AL=0，表明按键是功能键，光标键，还需要再调用本功能，才能返回按键的扩展码

- 09H

  显示字符串，响应Ctrl+C

  入口参数：DS：DX=字符串首地址，$\textcolor{red}{字符串必须以'$'为结束标志}$

  出口参数：无

  $\textcolor{red}{显示的内容不包括'$'，也会破坏AL寄存器的内容}$

- 0AH

  等待键入字符串，保存在输入数据缓冲区，同时显示字符串
  
  入口参数：DS：DX输入数据缓冲区首地址

![缓冲区定义格式](https://gitee.com/qiqibaba43/image/raw/master/202303172143258.png)

举例：允许用户输入15个字符（包括回车符）

```
BUF DB 100
	DB ?
	DB DUP(?)
```

### 2.BIOS功能调用

基本输入/输出系统：BIOS包括一组能够直接对硬件进行操作的子程序的集合

- 00H

  设置屏幕显示方式

  入口参数：AL=0 40*25   黑白文本方式

  ​					   AL=1 40*25   彩色文本方式

  出口参数：无

- 02H

  预置光标位置

  入口参数：BH=显示页号，DH=行号，DL=列号

  出口参数：无

- 03H

  入口参乎上：BH=显示页号

  出口参数：CH，CL=光标顶部扫描线，底部扫描线的行号

  ​					   DH，DL=光标在屏幕上的行列号

## 3.设计程序

## 4.宏指令设计

宏是源程序张的一段独立功能的程序代码，可以化简程序设计，增强可读性，传递参数更方便

宏指令的定义一般放在程序的首部

无参数宏指令：

```
宏指令名称 MACRO
	宏体
	ENDM
```

有参数宏指令：

```
宏指令名称 MACOR 哑元表
	宏体
	ENDM
```

`MACRO/ENDM`是宏体的定界语句

汇编时，用宏体替换宏指令

哑元是没有值的符号，用他们代表宏体中出现的操作码助记符，操作数

实元可以是立即数，寄存器操作数以及没有PTR运算符的内存操作数

# 6.中断系统

# 7.微型计算机系统串行通信

# 8.并行I/O接口

# 9.可编程定时/计数器

